<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[我的个人前端开发工具整理]]></title>
    <url>%2Fposts%2F8b40f68a%2F</url>
    <content type="text"><![CDATA[首先申明，我是极其反对那种“牛逼的大神用记事本也能写代码”的论调。我们写代码是为了创造有价值的东西，而不是单纯为了炫技。那在开发的过程中，如何提高我们的编码效率和能力才是最主要的，我经常会看到一些新人即便用了很好的工具，但效率还是很慢，不会装插件，不熟悉快捷键。俗话说 工欲善其事，必先利其器 ，今天就趁春节假期最后一天，整理了一下我的开发工具以及一些使用心得，希望能对大家有所帮助。编辑器Atom我的最爱，我最早是使用 DreamWeaver 的，后来脱离 PHP 专职做前端开发后，也就告别了 DW ，中途使用过 Sublime Text ，但其安装扩展的方式太不友好，就放弃了，后面也用过 VS code ，感觉和 Atom 不相上下，优势在于打开大文件极快，但插件感觉没 Atom 完善，所以目前还是以 Atom 为主。既然用了 Atom ，一定要了解两方面：快捷键和扩展。前者不用说了，任何工具我认为都应该去了解它的快捷键，关于 Atom 的快捷键可以看这篇文章《Atom 编辑器快捷键列表汇总整理》，并不用牢记所有快捷键，我会先大致浏览并实际操作一遍，然后回忆下开发中可能会遇到的情况，争对性的记住部分快捷键。扩展，这个才是 Atom 的灵魂，如果没有这些开发者贡献的插件，Atom 也就算个高级记事本。以下是我用到的扩展汇总：通用simplified-chinese-menu 中文语言包sync-settings 备份利器，重装电脑后最头疼的就是软件的配置，这个扩展能帮助你轻松还原开发环境，我特地整理过一篇使用教程《Atom 备份神器 —— Sync Settings》platformio-ide-terminal 终端工具file-icons 文件图标project-manager 项目管理工具，Atom 本身不具备项目的概念，所以这个插件超级实用，开发过程中可以方便切换项目minimap 代码全局预览，可代替滚动条，以下是相关的一些插件，比如在minimap-cursorlineminimap-find-and-replaceminimap-highlight-selectedminimap-linterminimap-pigmentsdocblockr 写注释用highlight-column 高亮当前列highlight-selected 高亮选中pigments 在代码中显示颜色pdf-view PDF 文件预览markdown 相关markdown-writermarkdown-preview-enhanced markdown 多功能组件，可同步预览，可导出 PDF 、HTML、图片，自带图片上传markdown-toc 生成目录tool-bar 自定义工具栏tool-bar-markdown-writer 配合 markdown-writer 使用tree-view-autoresizemulti-cursor前端emmet 快速编写 HTML 、CSS，这个插件 Atom 现在已经内置了，建议大家好好去了解下语法color-picker 取色器linter 代码错误检查linter-htmlhintlinter-jshintlinter-ui-defaultautocompleteautoclose-html 补全 HTML 闭合标签autocomplete-paths 补全路径GITmerge-conflicts 代码冲突需要合并的时候会用到tree-view-git-statusHBuilder我并不用 HBuilder 写代码，主要还是用它来打包 H5 APP 用，因为对这块研究不深，加上 HBuilder 傻瓜式的操作，所以目前还保留在电脑上。GIT 管理Sourcetree我基本很少在终端里敲 git 命令，一直以来都是用可视化界面的软件，早期是使用 TortoiseGit ，后来是因为 Sourcetree 界面更直观，并且内置了 git-flow 工作流，所以就义无反顾的丢弃了 TortoiseGit 了。Chrome前端开发用 Chrome 可以说是必须的，不要和我提 Firefox ，我只在测试兼容性的时候才会想起它。用 Chrome 有一部分原因是因为它的扩展，不过在介绍我的常用扩展前，先介绍一款 Chrome 的增强插件：GreenChrome ，我主要是看中它实现了双击关闭标签页的功能。以下是我的常用扩展：Adblock PlusAnything to QRcode 把网址转为二维码Cato 我主要是用来搜索收藏夹，但它的功能很强大，可以看这篇文章《Cato – 开源「命令行式」浏览器启动器》EditThisCookie cookie 管理器Octotree 用于 Github 的文档树插件GitCodeTree 用于码云的文档树插件GitHub HelperGitHub HovercardGoogle 翻译HTML5存储管理器多合一jQuery Audit 用于插件某个 DOM 上的事件和 data 信息JSON ViewerLast Tab chrome 在关闭最后一个标签后会自动关闭 chrome ，这个插件就是保证始终有一个锁定的空白标签，拯救了 Ctrl + W 党User-Agent Switcher for Chrome 模拟 UA 用捕捉网页截图 在需要截取整个页面的时候会用到恢复关闭的标签页其它Postman接口调试工具。Snipaste一款很出色的截图软件，而且是国人开发的，我用了之后就把 QQ 、微信自带的截图快捷键给屏蔽掉了。BootCDN稳定、快速、免费的前端开源项目 CDN 加速服务。Iconfont - 阿里巴巴矢量图标库据我了解，我司设计师找图标也是在 Iconfont 上找的，所以干脆就和设计师商量，设计师找的图标都添加到一个仓库里，前端开发直接生成 css 就行，减轻切图的工作。Slides适合技术人员做分享的在线幻灯片，够简单，没有太多复杂的功能。最后因为总有新工具出来，所以此文会不定期更新，当然文章里推荐的工具都很主观，都是我的个人使用感受，如果有更好的也欢迎交流。]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[电商平台商品SKU组合查询算法实现]]></title>
    <url>%2Fposts%2F8b2bd6f8%2F</url>
    <content type="text"><![CDATA[在大部分前端开发同学的日常工作中，很少会遇到算法问题，不得不说是种遗憾。但随着前端能处理的事务越来越多，多多少少也会遇到一些算法问题，就比如今天我打算讨论的这个问题——SKU组合查询。什么是 SKU我们看下维基百科是怎么解释的：最小库存管理单元（Stock Keeping Unit, SKU）是一个会计学名词，定义为库存管理中的最小可用单元，例如纺织品中一个SKU通常表示规格、颜色、款式，而在连锁零售门店中有时称单品为一个 SKU 。维基百科最小存货单位&nbsp;官方的解释可能有点晦涩，我举个例子，假设有一个手机，信息如下表格所示：颜色内存容量电池摄像头白色4G16G2200mAh1600万像素黑色6G32G2800mAh银色64G3200mAh红色这款手机分别提供了颜色、内存、容量、电池、摄像头 5 种可选属性，而表格中加粗部分组合在一起，就形成了一个 SKU ：黑色 + 4G + 32G + 3200mAh + 1600万像素问题描述还是拿手机举例，假设现在这台手机只有颜色和内存 2 种可选属性，颜色只有黑色和白色，内存只有 4G 和 6G 。我们把属性组合一下，列举出所有的 SKU ，同时也显示出库存数量和价格：颜色内存库存价格黑色4G01799黑色6G101999白色4G101899白色6G102099可以看到这组数据里 黑色 4G 已经没有存货，而 黑色 6G 、 白色 4G 、 白色 6G 分别还有 10 个货源在。那么，当用户对商品进行选择的时候，如果首先选择 黑色 ，对应的 4G 应该显示为不可选择状态，因为 黑色 4G 是没有货的。同样，如果先选择了 4G ，对应的 黑色 也应该显示为不可选择状态，因为 黑色 4G 还是没有货的。解决办法场景还原要解决这个问题，我们先模拟一个商品购买选择 SKU 的场景。一般情况下，后台会通过接口提供给我们两组数据，分别是 属性集 和 数据集 ，这里我就用两组固定数据模拟一下：12345678910111213141516171819202122232425262728// 属性集var key = [ &#123;name: '颜色', item: ['黑', '金', '白']&#125;, &#123;name: '内存', item: ['16G', '32G']&#125;, &#123;name: '运营商', item: ['电信', '移动', '联通']&#125;];// 数据集var sku = &#123; '黑;16G;电信': &#123;price: 100, count: 10&#125;, '黑;16G;移动': &#123;price: 101, count: 11&#125;, '黑;16G;联通': &#123;price: 102, count: 0&#125;, '黑;32G;电信': &#123;price: 103, count: 13&#125;, '黑;32G;移动': &#123;price: 104, count: 14&#125;, '黑;32G;联通': &#123;price: 105, count: 0&#125;, '金;16G;电信': &#123;price: 106, count: 16&#125;, '金;16G;移动': &#123;price: 107, count: 17&#125;, '金;16G;联通': &#123;price: 108, count: 18&#125;, '金;32G;电信': &#123;price: 109, count: 0&#125;, '金;32G;移动': &#123;price: 110, count: 20&#125;, '金;32G;联通': &#123;price: 111, count: 21&#125;, '白;16G;电信': &#123;price: 112, count: 0&#125;, '白;16G;移动': &#123;price: 113, count: 23&#125;, '白;16G;联通': &#123;price: 114, count: 24&#125;, '白;32G;电信': &#123;price: 115, count: 0&#125;, '白;32G;移动': &#123;price: 116, count: 26&#125;, '白;32G;联通': &#123;price: 117, count: 27&#125;&#125;; 有了这两组数据，就可以实现最基本的 SKU 选择功能了。用 属性集 去渲染 DOM，当用户选择好 SKU 后，程序将用户选择的属性拼接成一个 sku 字符串，比如 金;16G;电信 ，再根据这个字符串去 数据集 里获取库存和价格，演示如下： 上面这个演示有个最大的问题就是，必须把每个属性都选择后，才能获取到对应的库存和价格，如果没有选择完整，就无法获取对应的数据。 原因也很简单，因为 数据集 里没有提供嘛。比如我只选择了 白 ，那么当前拼接出来的 sku 则是 白;; ，自然找不到这条 sku 的相关数据。那要怎么解决呢？那就把 数据集 加工一下嘛。 数据加工我拿 数据集 里某一条 sku 举例，比如 黑;16G;电信 ，将这个 sku 进行更小的拆分组合，希望得到以下的结果： ;; 黑;; ;16G; ;;电信 黑;16G; 黑;;电信 ;16G;电信 黑;16G;电信 这里会涉及到本文中最核心的一个算法，让我们再仔细看下举例的这个 sku ，如果将它转为数组，就是： 1['黑', '16G', '电信'] 如果把最终希望得到的结果也转为数组，那就是： 12345678['', '', '']['黑', '', '']['', '16G', '']['', '', '电信']['黑', '16G', '']['黑', '', '电信']['', '16G', '电信']['黑', '16G', '电信'] 然后仔细观察一下这组数据，看出些端倪了么？ 没看出来？没关系，我们把这个 sku 再增加一个属性，如果数组是这样子的： 1['黑', '16G', '电信', '2800mAh'] 那最终希望得到的结果也会有变化 1234567891011121314151617181920['', '', '', '']['黑', '', '', '']['', '16G', '', '']['', '', '电信', '']['', '', '', '2800mAh']['黑', '16G', '', '']['黑', '', '电信', '']['黑', '', '', '2800mAh']['', '16G', '电信', '']['', '16G', '', '2800mAh']['', '', '电信', '2800mAh']['黑', '16G', '电信', '']['黑', '16G', '', '2800mAh']['黑', '', '电信', '2800mAh']['', '16G', '电信', '2800mAh']['黑', '16G', '电信', '2800mAh'] 相信有人已经看出来了，这里需要实现的一个算法就是： 从 m 个不同元素中取出 n 个元素的组合数 我们可以分别去验证一下 123456789101112131415161718192021222324252627// 源数据 ['黑', '16G', '电信', '2800mAh']// 从 4 个元素中取 0 个元素的组合['', '', '', '']// 从 4 个元素中取 1 个元素的组合['黑', '', '', '']['', '16G', '', '']['', '', '电信', '']['', '', '', '2800mAh']// 从 4 个元素中取 2 个元素的组合['黑', '16G', '', '']['黑', '', '电信', '']['黑', '', '', '2800mAh']['', '16G', '电信', '']['', '16G', '', '2800mAh']['', '', '电信', '2800mAh']//从 4 个元素中取 3 个元素的组合['黑', '16G', '电信', '']['黑', '16G', '', '2800mAh']['黑', '', '电信', '2800mAh']['', '16G', '电信', '2800mAh']//从 4 个元素中取 4 个元素的组合['黑', '16G', '电信', '2800mAh'] 实现代码如下（非原创）： 123456789101112131415161718192021222324252627282930313233// 从m中取n的所有组合function getFlagArrs(m, n) &#123; var flagArrs = [], flagArr = [], isEnd = false; for(var i = 0; i &lt; m; i++)&#123; flagArr[i] = i &lt; n ? 1 : 0; &#125; flagArrs.push(flagArr.concat()); // 当n不等于0并且m大于n的时候进入 if(n &amp;&amp; m &gt; n)&#123; while(!isEnd)&#123; var leftCnt = 0; for(var i = 0; i &lt; m - 1; i++)&#123; if (flagArr[i] == 1 &amp;&amp; flagArr[i + 1] == 0)&#123; for(var j = 0; j &lt; i; j++)&#123; flagArr[j] = j &lt; leftCnt ? 1 : 0; &#125; flagArr[i] = 0; flagArr[i + 1] = 1; var aTmp = flagArr.concat(); flagArrs.push(aTmp); if(aTmp.slice(-n).join('').indexOf('0') == -1)&#123; isEnd = true; &#125; break; &#125; flagArr[i] == 1 &amp;&amp; leftCnt++; &#125; &#125; &#125; return flagArrs;&#125; 这个方法在调用后返回的 flagArrs 并不是最终所需要的业务数据，而是返回一组这样的数据 这时候需要用源数据，也就是 [&#39;黑&#39;, &#39;16G&#39;, &#39;电信&#39;, &#39;2800mAh&#39;] 依次循环填坑，将数组中为 1 的部分替换掉，0 的部分则留空，这样就能得到我们需要的数据了。 解决到这一步后，后面的工作就相对轻松了。 我们已经能根据 黑;16G;电信 得到这样的一组数据了 12345678['', '', '']['黑', '', '']['', '16G', '']['', '', '电信']['黑', '16G', '']['黑', '', '电信']['', '16G', '电信']['黑', '16G', '电信'] 但这数据里并没有存放库存以及价格信息，这时候我们先观察一下数据，一个 sku 就能得到一组这样的数据，换一个 sku 一样还是能得到一组类似的数据，比如换成 黑;16G;移动 就会得到 12345678['', '', '']['黑', '', '']['', '16G', '']['', '', '移动']['黑', '16G', '']['黑', '', '移动']['', '16G', '移动']['黑', '16G', '移动'] 发现了么？其中有几个数据是一样的，比如都有出现 [&#39;黑&#39;, &#39;&#39;, &#39;&#39;] [&#39;&#39;, &#39;16G&#39;, &#39;&#39;] [&#39;黑&#39;, &#39;16G&#39;, &#39;&#39;] …… 我只需把数据一样的库存进行累加，同时把价格存到一个数组里。这样把 数据集 里所有的 sku 都循环一遍后，对应的库存数就统计出来了。比如每个 sku 都会出现 [&#39;&#39;, &#39;&#39;, &#39;&#39;] ，那累计得出的自然也就是该商品的总库存数量；再比如 sku 里有出现过 [&#39;黑&#39;, &#39;&#39;, &#39;&#39;] ，最终累计得出的就是该商品颜色为黑色的库存数量。 至于价格，因为每次循环，价格都被保存到与 sku 相对应的一个数组里，比如 [&#39;&#39;, &#39;&#39;, &#39;&#39;] 就会保存 数据集 所有 sku 的价格， [&#39;黑&#39;, &#39;&#39;, &#39;&#39;] 则会保存与黑色相关的所有价格。如果要获取价格，通过 js 的 Math 对象能很轻松的获取数组里的最大值和最小值。 1234// 最大值Math.max.apply(Math, Array);// 最小值Math.min.apply(Math, Array); 至此，我们已经能实现用户选择一个或多个属性时，均能展示当前的库存和价格信息，演示如下： 关联 SKU 验证先恭喜你离最终我们所希望达到的效果，只差一步了。 好，回归问题，我们希望当用户点击属性选择的时候，程序能去验证一些可能点击的属性，提前把 0 库存的属性设为禁止选中状态。我把这里的操作分为两种情况，一种是当用户只差一个属性没选的时候，另一种是当用户所有属性都选择的时候。 当用户只差一个属性没选 这种情况下，只需将已选中的属性依次和未选中属性里的值拼接，如果拼接出来的 sku 库存为 0 ，则将对应未选中属性的值设为禁止状态。如果没理解，下面我用张表格具体举例，加粗表示已经选中的属性。 颜色 内存 容量 白色 4G 16G 黑色 6G 32G 银色 64G 红色 上面表示颜色和内存都已选好，程序要做的事就是循环容量属性里的值，然后把颜色和内存里已选择的值组成 sku 去检查库存。这里会验证 3 组 sku ： 黑色;4G;16G 黑色;4G;32G 黑色;4G;64G 如果验证出 黑色;4G;32G 的库存是 0 ，那就把 32G 设为禁止选择。 当用户所有属性都选择 这种情况下，则需要将每组属性里未被选中的值和其它已选中的属性拼接，将拼接出来的 sku 进行验证。还是用张表格来举例吧。 颜色 内存 容量 白色 4G 16G 黑色 6G 32G 银色 64G 红色 第一步，先将颜色里未选择的值去组成 sku ： 白色;4G;64G 银色;4G;64G 红色;4G;64G 如果验证出 银色;4G;64G 的库存是 0 ，那就把 银色 设为禁止选择。 第二步，再将内存里未选择的值去组成 sku ： 黑色;6G;64G 如果验证出 黑色;6G;64G 的库存是 0 ，那就把 6G 设为禁止选择。 最后一步，将容量里未选择的值去组成 sku ： 黑色;4G;16G 黑色;4G;32G 如果验证出 黑色;4G;32G 的库存是 0 ，那就把 32G 设为禁止选择。 按照这个思路，我们最终的演示也出来了 总结整个功能实现的思路相对还是比较清晰的，比较费时的就是两个算法的实现。 第一个算法，将 数据集 进行更小的拆分组合时候，我最开始的想法是用 属性集 去进行组合和递归，但一直无法得出最终想要的结果，于是才改从 数据集 下手。 第二个算法，点击验证 SKU 其实还可以继续优化，我举个例子： 颜色 内存 容量 白色 4G 16G 黑色 6G 32G 银色 64G 红色 如上表格，如果 黑色;4G;16G 和 黑色;6G;16G 的库存都是 0 ，那么在用户选中 黑色 的时候，则应该把 16G 设为禁止选中状态。但基于我的算法方案，当用户只选中 黑色 的时候，却不属于两种情况当中的任何一种，则无法进行验证。 关于 SKU 的算法还是有很多优化的地方，当然一定也有还没考虑到的问题。本文抛砖引玉，希望能给同行一些思路。 参考 用例子理解排列组合及基本公式如何计算 淘宝SKU组合查询算法实现 Sku 多维属性状态判断算法]]></content>
      <categories>
        <category>WEB开发</category>
      </categories>
      <tags>
        <tag>SKU</tag>
        <tag>电商</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于 jQuery WeUI 的通讯录模块]]></title>
    <url>%2Fposts%2F8913e16b%2F</url>
    <content type="text"><![CDATA[由于 jQuery WeUI 本身没有提供通讯录模块，所以自己写了一个 demo 页面，实现了基本展示以及右侧字母快捷导航功能。考虑到通讯录模块对界面展示的定置化需求会比较大，所以没有封装成插件。下载源码后可自行修改联系人界面样式。功能比较简单，实现也没用几句代码，所以也没有太多可介绍的，感兴趣的直接看源码吧。Github 地址]]></content>
      <categories>
        <category>WEB开发</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>WeUI</tag>
        <tag>通讯录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gulp 前端自动化工作流]]></title>
    <url>%2Fposts%2F48995743%2F</url>
    <content type="text"><![CDATA[初识 Gulp 是因为公司项目逐渐需要进行前后端分离，既然脱离了世界上最好的语言 PHP 后，也就没了 include 函数的支持，面临最大的问题就是页面 header 、 footer 等一些公用部分的代码要怎么在每个页面上引用，手动复制肯定不行。在网上搜寻一番后，发现了 gulp-file-include 这个插件，后面的故事，就像每个热恋中的人一样，恨不得每天都和 Gulp 腻在一起。经过半年的相处，也大概摸透了 Gulp 的一些习性，并根据工作上的流程，整理了一套公司内部的前端自动化部署的开发环境。本文不是 Gulp 的使用介绍，关于 Gulp 入门，请自行学习。gulp-automation少罗嗦，先看东西如何使用安装首先将 gulp-automation 下载到本地，下载好后推荐使用 Yarn 安装1$ yarn install 运行1$ gulp 成功运行后，会自动打开浏览器并访问 http://localhost:3000 页面 编写代码原始页面全部在 page 目录下编写。打开 page 目录会看到有一个 index.html 页面 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;!-- 引用公用页面采用以下方式 --&gt; @@include('include/head.html')&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Test Page !&lt;/h1&gt; &lt;div class="test-img"&gt;&lt;/div&gt; &lt;script src="@@webRoot/static/js/main.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 可以看到，和正常写 HTML 代码没什么区别。对于公用代码的引用，通过这样语法进行引用 1@@include(&apos;&lt;页面地址&gt;&apos;) 这里其实就是用到了 gulp-file-include ，更多语法参数点 这里 查看！ 通过上面可得知，page/include/ 是用来存放公用部分的代码的。 这时候可能又会遇到一个问题，不是所有网站的页面都存放在根目录下的，可能会按照功能模块的不同，划分出不同的文件夹来存放不同的页面，比如我们经常会看到这样的链接： www.xxx.com/index.html www.xxx.com/news/detail.html?nid=2 www.xxx.com/product/info.html?pid=1 网站首页存放在根目录，新闻相关页面存放在 news 文件夹下，产品相关页面存放在 product 文件夹下。 这里我的做法是把所有模块都放到 page/module/ 目录下，打开目录就可以看到一个 banner 文件夹，你可以在这个目录下随意创建其它模块文件夹。 发布/打包发布 1$ gulp build 发布并打包 1$ gulp build --z 修改 package.json 里的 name 参数，可改变打包出来压缩包文件的命名打包时使用了 gulp-tinypng-nokey 插件进行图片压缩，需要将图片上传到服务器压缩后再下载，请确保打包时网络畅通 参考 Gulp 中文网 Gulp探究折腾之路(I) gulp使用小结(一) 前端构建工具gulpjs的使用介绍及技巧 常用gulp插件介绍(一) 重构你的gulpfile]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Hexo 和 Github 快速搭建个人博客]]></title>
    <url>%2Fposts%2F15e2d21f%2F</url>
    <content type="text"><![CDATA[网上类似的教程一搜一大把，写得其实很详细。但对于初次接触的我来说，这是一次全新的体验。所以在经历了多次「安装——配置——部署——删除——再安装——」之后，大概弄懂了整个流程。正好也是博客的开篇文章，记录一下整个搭建流程，加深印象。安装安装前提在安装前，先确保电脑上已经安装了 Node.js 和 Git 环境。安装 Hexo1$ yarn global add hexo-cli 官方是使用 npm 进行安装，个人推荐使用 yarn 进行安装，关于 yarn 和 npm 优劣分析，可以参考这篇文章《Yarn vs npm: 你需要知道的一切》 建站初始化先新建一个 blog 文件夹，然后进入该文件夹运行： 1$ hexo init 初始化完成后， blog 文件夹的目录如下： 本地访问继续运行： 1$ hexo g &amp;&amp; hexo s 运行成功后会发现提示信息： Hexo is running at http://localhost:4000/. 这个时候访问 http://localhost:4000/ 就会发现网站已经建好了！ 常用命令以下 4 个是我在搭建过程中发现使用频率最高的 4 个命令，甚至我感觉只要会这 4 个命令就可以了。 generate 生成静态文件 1$ hexo generate server 启动服务器 1$ hexo server deploy 部署网站 1$ hexo deploy clean 清除缓存文件（db.json）和已生成的静态文件（public） 1$ hexo clean 更多命令和参数请看 这里 ！ 部署到 Github首先先到 Github 上新建一个仓库，仓库名的格式为： 1&lt;username&gt;.github.io 例如我的就是 hooray.github.io ，创建好后，复制仓库的 HTTPS 地址，打开 blog 根目录下的 _config.yml 文件，拖动到底部找到 deploy 配置，按照以下格式修改并保存： 123deploy: type: git repo: &lt;仓库地址&gt; 这个时候安装 hexo-deployer-git 自动部署发布工具 1$ yarn add hexo-deployer-git 安装完成后，就可以去发布了 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 第一次发布会提示输入 Github 账号和密码： 稍微等待一会，会提示发布成功，然后在浏览器里测试访问 https://hooray.github.io ，大功告成！ 这时候打开仓库会发现 Hexo 其实是把 public 目录下生成好的静态页面和相关资源上传到了 master 分支下，但是本地博客的开发环境是没有上传到仓库里的，如果换一台电脑想继续写博客更新，这就没办法了。 要解决这个问题其实也很简单，可以单独再创建一个仓库，专门用于上传开发环境。但我的做法是创建一个分支，比如 hexo 分支，这个分支专门用来上传开发环境。 需要注意，通过 git clone 下来的 NexT 主题，需要手动删除隐藏的 .git 文件夹，不然 NexT 主题整个文件夹都不会被提交。 主题安装 NexT1$ git clone https://github.com/theme-next/hexo-theme-next themes/next 我安装的是 6.0.x 的 NexT ，但在 NexT 官网上提供的还是 5.1.x 的安装命令和文档，因为 6.0.x 和 5.1.x 的配置有所不同，建议第一次练习搭建还是使用 5.1.x ，熟悉配置文档后，再用 6.0.x 。 修改 _config.yml 文件里 theme 配置： 1theme: next 配置虽然我安装的是 6.0.x ，但大部分还是可以根据 NexT 主题配置 文档来修改，以下会介绍一些文档中没有提及的设置。 以下分别用：站点配置 _config.yml主题配置 themes/next/_config.yml区分两个配置文件 设置网站语言打开 站点配置 找到 language 修改 1language: zh-CN 开启导航打开 主题配置 找到 menu ，将需要开启的导航前面的 # 删掉 123456789menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap commonweal: /404.html || heartbeat 这个时候会发现网站上已经能看到导航了，但点击却提示找不到页面。 这时需要去新建对应的页面，比如新建 标签 页： 1$ hexo new page "tags" 新建好后会在 source/tags/index.md 看到刚新建的文件，在 Front-matter 区域增加一句： 1type: &quot;tags&quot; 其它导航页面操作一样。 增加评论模块在 NexT 官网上可以查到第三方评论系统的配置方法，我最终选择的是 Gitment 做为博客的评论系统，因为 Gitment 是一款基于 GitHub Issues 的评论系统，这样对于评论的管理完全可以在一个仓库里实现。 步骤如下： 首先点击 这里 注册一个新的 OAuth Application 。Homepage URL 和 Authorization callback URL 均填写博客地址就行 接着注册好后会得到 Client ID 和 Client Secret ，打开 主题配置 找到 gitment 对照着修改 123456789101112gitment: enable: true mint: true count: true lazy: false cleanly: true language: github_user: hooray github_repo: hooray.github.io client_id: xxxxxxxxxx client_secret: xxxxxxxxxx redirect_protocol: 最后就是发布页面，发布好后，访问页面并使用你的 GitHub 账号登录（请确保账号是上面 repo 的拥有者），点击初始化按钮。之后其他用户就可以在该页面发表评论了。 需要注意的是，Gitment 不支持链接里面有中文，不然初始化评论的时候会提示 Error: Validation Failed 。解决办法就是创建文章的时候，使用纯英文当文件名。 文章链接唯一化有时候可能需要修改一篇已经发布的文章的标题，或者是修改它的发布时间，这样就导致文章链接地址会变化，也就间接导致 Gitment 评论丢失。 解决这个问题需要安装 hexo-abbrlink 工具 1$ yarn add hexo-abbrlink 安装好后打开 站点配置 找到 permalink 修改 1permalink: posts/:abbrlink/ 并在增加如下代码 1234# abbrlink configabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex 配置好后重新发布就能看到效果。 个人强烈推荐安装这个工具，这样创建文章的时候可以继续使用中文名，如果博客里文章多了，还是中文一目了然，也方便管理，同时也解决了上面的问题，链接永久唯一化后对 SEO 会更友好。 参考 Hexo 文档 NexT 使用文档 搭建个人博客-hexo+github详细完整步骤 Gitment：使用 GitHub Issues 搭建评论系统 hexo的next主题个性化配置教程 为NexT主题添加文章阅读量统计功能 hexo 摸爬滚打之进阶教程]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
</search>
